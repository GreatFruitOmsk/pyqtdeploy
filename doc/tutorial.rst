Tutorial
========

:program:`pyqtdeploy` is itself deployable and the root of the source package
contains an appropriate ``pyqtdeploy.pdy`` project file.  In this section we
use this as the basis of explaining :program:`pyqtdeploy`'s graphical user
interface.


.. _ref-directory-structure:

Choosing a Directory Structure
------------------------------

In order to deploy an application you have to assemble the various parts, e.g.
target specific versions of Python, PyQt and sip.  In deciding how to organise
this you might consider the following:

- consistency so that you can easily find things

- avoiding hardcoded paths in project files to make it easier to share them
  with other developers

- supporting multiple targets and easily switching between them.  For example
  you may be developing a mobile application that will be deployed to iOS and
  Android but are doing the main development and testing under Linux.

We now describe a directory structure that addresses these issues.  It is only
a recommendation and not a requirement.

There is a top-level directory called ``pyqtdeploy``.  Everything else will be
placed in this directory or one of its sub-directories.  It does not matter
where this directory is in the filesystem.  You may create it in your home
directory or you may place it in a location where it can be shared with other
users.  Once it is set up there is no need for it to be updated as part of the
process of deploying an application.  In other words, a shared ``pyqtdeploy``
directory can be read-only for all users.

Within the ``pyqtdeploy`` directory we create a system root directory for each
target we are deploying to.  For example we might create directories called
``sysroot-linux``, ``sysroot-ios`` and ``sysroot-android``.  We can use an
environment variable to point to the particular target system root directory we
wish to use.  If we then use that environment variable in the project file then
we can switch between targets without having to update the project file and so
makes it possible to share the project file with other users.

:program:`pyqtdeploy` has the option to run :program:`qmake` which itself is
target-specific and may be installed in different locations for different
users.  We therefore create a symbolic link in each target-specific system root
directory that points to the corresponding target-specific Qt installation.
For example if you have installed the combined iOS and Android Qt binary
installer in its default location then the iOS Qt directory will be
``$HOME/QtX.Y.X/X.Y/ios`` and the Android Qt directory will be
``$HOME/QtX.Y.X/X.Y/android_arm7`` (where ``X.Y.Z`` is the version number of
Qt).

This approach can be extended further by creating a symbolic link to the target
specific system root directory and setting the environment variable to the
location of the symbolic link.  To switch between targets you then just change
the destination of the symbolic link.  If you develop with multiple terminal
windows open then this has the advantage is that you only need to make the one
change and it will take effect in all terminals - otherwise you need to
remember to update the environment variable in each of your terminals.

Throughout this documentation it is assumed that you have set an environment
variable :envvar:`SYSROOT` which points to your target specific root directory.


Creating a :program:`pyqtdeploy` Project
----------------------------------------

The first stage of deploying a PyQt application is to create a
:program:`pyqtdeploy` project for it by running::

    pyqtdeploy myproject.pdy

This will create a new project, or open an exiting one if the file
``myproject.pdy`` already exists.  A project is simply a file with a ``.pdy``
extension.

A GUI will be displayed which consists of a ``File`` menu and a set of tabbed
pages that handle different aspects of the application's specification and
building.

The ``File`` menu contains the usual set of options to create a new project,
open an existing project, save a project and rename a project.

For the remainder of this tutorial we will use the ``pyqtdeploy.pdy`` project
file included in the root of the source package.


Defining the Application Source
-------------------------------

Python applications are usually structured in one of the following ways:

- a single standalone executable script that is installed in a ``bin``
  directory somewhere

- a package installed in ``site-packages`` with a separate executable script
  installed in a ``bin`` directory

- a package installed in ``site-packages`` with a separate executable script
  that is automatically generated by :mod:`setuptools`.  The script calls an
  *entry point* in the package.  An *entry point* is the name of a module in
  the package and the name of a callable within the module separated by a
  ``:``.

:program:`pyqtdeploy` itself uses the :mod:`setuptools` based structure.

The tab for defining the application source is shown below.

.. image:: /images/application_source_tab.png
    :align: center

**Name**
    is used to specify the name of the final application executable.  If it is
    not specified then it is derived from the name of the main script file.  If
    the application does not have a main script file then the name is derived
    from the name of the application package.

**Main script file**
    is used to specify the name of the executable Python script used to invoke
    the application.  It should not be specified if an entry point is
    specified.

    .. note::
        Whenever a file or directory is specified, :program:`pyqtdeploy` always
        saves its name relative to the directory containing the project file if
        possible.  In this particular example the ``pyqtdeploy`` package
        directory is in the same directory as the ``pyqtdeploy.pdy`` project
        file.  Also, whenever a file or directory name is entered,
        :program:`pyqtdeploy` allows the embedding of environment variables
        which will be expanded when necessary.

**Entry Point**
    is used to specify the entry point of a :mod:`setuptools`-based
    application.  It should not be specified if a main script file is
    specified.

**sys.path**
    is used to specify additional directories that will be added to
    :data:`sys.path`.  By default :program:`pyqtdeploy` generates an
    application that does not support the importing of packages or extension
    modules that are not embedded in the application.  Indeed, some platforms
    specifically disallow this.  However there are circumstances where this
    ability is desired:

    - you need to use an extension module that does not support being
      statically compiled

    - you allow users to write Python code that is imported by the application
      to configure or extend its functionality.

    The path is specified as a space separated list of directories.  Single or
    double quotes may be used to embed spaces in directory names.  Environment
    variables (specified using the standard UNIX notation) are expanded when
    the application is run.  Any relative directory names are assumed to be
    relative to the directory containing the application executable.  UNIX path
    separators should be used - the application will automatically do the
    appropriate conversions when running on Windows.

    .. note::
        If you wish to allow the importing of external extension modules then
        you will also need to ensure that Python has been built with this
        enabled.  See the :option:`--enable-dynamic-loading` option of the
        :option:`configure` action.

**PyQt5**
    is used to specify that the application is a PyQt5 application.

**PyQt4**
    is used to specify that the application is a PyQt4 application.

**Scan...**
    is clicked to specify the name of the directory containing the Python
    package that implements the application.  (If the application consists of a
    single script then you would not use this.)  The hierachy will be scanned
    for all files and directories that don't match any of the specified
    exclusions and will be displayed in the main area of the tab.  Each file or
    directory can then be checked if it is to be included in the package.  Note
    that if the main script file is a part of the application package then it's
    entry must be explicitly unchecked (i.e. excluded).

    .. note::
        Non-Python (i.e. data) files can also be included in the package.  An
        application typically accesses such files by using the
        :func:`QFileInfo.absolutePath` function on the :data:`__file__`
        attribute of a module to obtain the name of the directory containing
        the data file.  This approach will also work with deployed applications
        so long as the file is accessed using the :class:`~PyQt5.QtCore.QFile`
        class (rather than the standard Python file access functions).

**Remove all**
    is clicked to remove all the scanned files and directories.

**Include all**
    is clicked to check all scanned files and directories so that they are
    included in the application package.

**Exclude all**
    is clicked to uncheck all scanned files and directories so that they are
    excluded from the application package.

**Exclusions**
    is used to specify the list of *glob*-style patterns that are applied to
    the scanned files and directories.  Those items that match are then
    completely ignored.  To edit the list just double-click on the entry to
    modify or delete.  To add a new entry just double-click the list after the
    last entry.


Defining the PyQt Modules
-------------------------

The tab for defining the PyQt modules used by the application is shown below.
If the application is a PyQt4 application then the PyQt4 modules will be shown
instead.

.. image:: /images/pyqt_modules_tab.png
    :align: center

Simply check all the PyQt modules that are used.

:program:`pyqtdeploy` understands the dependencies between the different PyQt
modules and will automatically check any additional modules that are required.
Therefore the same effect could have been achieved by only specifying the
:mod:`~PyQt5.QtWidgets` module.  However it is better to explicitly specify all
the modules imported directly by the application.

.. note::
    These modules must be compiled statically.  If you plan to use a separately
    deployed copy of PyQt that will be dynamically loaded by your application
    then do not specify any modules here.


Defining the Standard Library Packages
--------------------------------------

The tab for defining the Python standard library packages used by the
application is shown below.

.. image:: /images/stdlib_packages_tab.png
    :align: center

**Target Python version**
    is used to specify version of Python that you are targetting.

**Use SSL support**
    is used to specify if the application requires SSL support to be enabled.
    Several packages in the Python standard library will enable SSL related
    functionality if it is available - even if your application doesn't itself
    import the :mod:`ssl` module.

The main part of the tab contains all of the packages contained in the target
Python version's standard library.  Simply check those packages that the
application explicitly imports.  :program:`pyqtdeploy` understands the
inter-package dependencies and will automatically select any additional
packages that are required.  It will also automatically select any packages
that are needed internally by the Python interpreter.

Here we have explicitly selected the :mod:`argparse` module and the
:mod:`_thread`, :mod:`abc`, :mod:`array`, :mod:`atexit` and :mod:`calendar`
modules have been selected automatically.

The remaining part of the tab relates to non-system libraries that may need to
be linked with the application.  Typically they correspond to packages in the
standard library that wrap them.  If a library is required, because a package
that uses it is required, then the entry for the library will be enabled.  The
corresponding ``DEFINES``, ``INCLUDEPATH`` and ``LIBS`` fields will also be
editable allowing those values to be set appropriately.  For example, if you
have built a static copy of the library then you may need to specify the
location of the library's header files in the ``INCLUDEPATH`` field and add a
``-L`` flag to the ``LIBS`` field if the library is not installed in locations
that will be found automatically by the compiler and linker.

:program:`pyqtdeploy` does not import any package from the standard library
that uses any of these libraries and so they are all disabled.


Defining Additional Packages
----------------------------

The sub-tab for defining additional packages used by the application is shown
below.

.. image:: /images/other_packages_tab.png
    :align: center

This tab is used to scan a number of directories containing additional Python
packages (i.e. other than those that are part of the Python standard library).
You then specify which individual modules are needed, either implicitly or
explicitly, by the application.

To edit the list of directories just double-click on the entry to modify or
delete.  To add a new entry just double-click the list after the last entry.

In many cases you will want to add the ``site-packages`` directory of your host
Python interpreter, i.e. the interpreter being used to develop the application,
where all the additional packages required by your application are already
installed.

:program:`pyqtdeploy` does not use any additional Python packages.


Defining Additional Extension Modules
-------------------------------------

The sub-tab for defining additional C extension modules used by the application
is shown below.

.. image:: /images/other_extension_modules_tab.png
    :align: center

This tab is used to specify any additional C extension modules (i.e. other than
those that are part of the Python standard library) that will be statically
linked into the Python interpreter library.  For each extension module its name
and the directory containing it must be specified.  On Windows an extension
module will have a ``.lib`` filename suffix.  The suffix will be ``.a`` on most
other platforms.

To edit the list just double-click on the entry to modify or delete.  To add a
new entry just double-click the list after the last entry.

:program:`pyqtdeploy` does not use any additional C extension modules.


Defining File and Directory Locations
-------------------------------------

The tab for defining the locations of various files and directories needed by
:program:`pyqtdeploy` is shown below.

.. image:: /images/locations_tab.png
    :align: center

**Interpreter**
    is used to specify the **host** Python interpreter used to compile all of
    the Python modules used by the application.  This must be the same version
    as the **target** Python installation to ensure that the compiled bytecode
    can be executed by the deployed application.  (Of course if you are not
    cross-compiling the application then the host and target Python
    installations can be the same.)

**Source directory**
    is used to specify the name of the directory containing the Python source
    code.

**Include directory**
    is used to specify the name of the directory containing the target Python
    installation's ``Python.h`` file.

**Python library**
    is used to specify the name of the target Python interpreter library.  Note
    that in this example the library is specified as a UNIX archive, however
    :program:`pyqtdeploy` will interpret it correctly on Windows.

**Standard library directory**
    is used to specify the name of the directory containing the target Python
    interpreter's standard library.

**Build directory**
    is used to specify the name of the directory into which all the code
    generated by :program:`pyqtdeploy` will be placed.  It will be created
    automatically if necessary.

**qmake**
    is used to specify the name of the :program:`qmake` executable that is
    optionally used to build a ``Makefile`` for the application.


Building the Application
------------------------

Normally building an application is done from the command line.  However during
the debugging of the deployment it is convenient to be able to complete the
whole build process (generating code, running :program:`qmake`, running
:program:`make` and running the final application executable) from within the
GUI.

The tab for building the application is shown below.

.. image:: /images/build_tab.png
    :align: center

The main area of the tab shows the output of the various stages of the build.

**Build**
    is clicked to build the application.  The application code and
    :program:`qmake` ``.pro`` file will be generated in the build directory.
    What else is done depends on the additional build steps that have been
    specified.

**No asserts**
    is clicked to specify that all ``assert`` statements should be removed from
    frozen Python code.

**No docstrings**
    is clicked to specify that all docstrings should be removed from frozen
    Python code.

**Clean before building**
    is clicked to specify that the build directory is deleted and recreated
    before starting a new build.

**Capture console output**
    is clicked to specify that ``console`` is always added to the ``CONFIG``
    variable in the generated ``.pro`` file.  This is only useful on Windows
    and ensures that, even for a GUI application, tracebacks (e.g. about
    missing modules) are captured and displayed.

**Verbose output**
    is clicked specify that additional information is displayed during the
    build process.

**Run qmake**
    is clicked to specify that :program:`qmake` will be run after generating
    the application code.  If this is disabled the later build steps will be
    disabled automatically.

**Run make**
    is clicked to specify that :program:`make` (or :program:`nmake` on Windows)
    will be run after running :program:`qmake`.  The earlier build steps will
    be enabled automatically.  If this is disabled the later build steps will
    be disabled automatically.

**Run application**
    is clicked to specify that the application executable will be run after
    running :program:`make`.  The earlier build steps will be enabled
    automatically.

    .. note::
        This only makes sense if you are building natively and not
        cross-compiling.


Creating a Deployable Package
-----------------------------

Assuming you have built the application code and the :program:`qmake` ``.pro``
file, the build directory will now contain the source of (as far as
:program:`qmake` is concerned) a Qt based C++ application.  To convert this
into a deployable application you must follow the appropriate Qt documentation
for compiling and packaging for your target platform.

For desktop platforms this is probably as simple as running :program:`qmake`
followed by :program:`make` (or :program:`nmake` on Windows).

.. note::
    Make sure the version of :program:`qmake` used is the same as the one used
    to build PyQt.

For mobile platforms this will be considerably more complicated.
